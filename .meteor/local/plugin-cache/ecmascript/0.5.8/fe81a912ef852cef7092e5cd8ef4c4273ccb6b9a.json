{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/practicalmeteor:mocha/test/integration/helpers.js","filenameRelative":"/packages/practicalmeteor:mocha/test/integration/helpers.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/practicalmeteor:mocha/test/integration/helpers.js.map","sourceFileName":"/packages/practicalmeteor:mocha/test/integration/helpers.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"helpers"},"ignored":false,"code":"var spawn = require('child_process').spawn;\nvar path = require('path');\nvar fs = require('fs');\n\nmodule.exports = {\n  /**\n   * Invokes the mocha binary for the given fixture with color output disabled.\n   * Accepts an array of additional command line args to pass. The callback is\n   * invoked with a summary of the run, in addition to its output. The summary\n   * includes the number of passing, pending, and failing tests, as well as the\n   * exit code. Useful for testing different reporters.\n   *\n   * Example response:\n   * {\n   *   pending: 0,\n   *   passing: 0,\n   *   failing: 1,\n   *   code:    1,\n   *   output:  '...'\n   * }\n   *\n   * @param {string}   fixturePath\n   * @param {array}    args\n   * @param {function} fn\n   */\n  runMocha: function () {\n    function runMocha(fixturePath, args, fn) {\n      var path;\n\n      path = resolveFixturePath(fixturePath);\n      args = args || [];\n\n      invokeMocha(args.concat(['-C', path]), function (err, res) {\n        if (err) return fn(err);\n\n        fn(null, getSummary(res));\n      });\n    }\n\n    return runMocha;\n  }(),\n\n  /**\n   * Invokes the mocha binary on the code of the body of the function.\n   * Accepts an array of additional command line args to pass. The callback is\n   * invoked with a summary of the run, in addition to its output. The summary\n   * includes the number of passing, pending, and failing tests, as well as the\n   * exit code. Useful for testing different reporters.\n   *\n   * Example response:\n   * {\n   *   pending: 0,\n   *   passing: 0,\n   *   failing: 1,\n   *   code:    1,\n   *   output:  '...'\n   * }\n   *\n   * @param {function} fixture\n   * @param {array}    args\n   * @param {function} fn\n   */\n  runMochaFunction: function () {\n    function runMochaFunction(fixture, args, fn) {\n      var path = resolveFixturePath(fixture.name + '.js' || 'tempfile.js');\n      args = args || [];\n\n      var fixtureContent = 'var fn = ' + fixture.toString() + '; fn()';\n      fs.writeFileSync(path, fixtureContent, 'utf8');\n\n      function cleanup() {\n        fs.unlink(path);\n        fn.apply(this, arguments);\n      }\n\n      invokeMocha(args.concat(['-C', path]), function (err, res) {\n        if (err) {\n          return cleanup(err);\n        }\n\n        cleanup(null, getSummary(res));\n      });\n    }\n\n    return runMochaFunction;\n  }(),\n\n  /**\n   * Invokes the mocha binary for the given fixture using the JSON reporter,\n   * returning the parsed output, as well as exit code.\n   *\n   * @param {string}   fixturePath\n   * @param {array}    args\n   * @param {function} fn\n   */\n  runMochaJSON: function () {\n    function runMochaJSON(fixturePath, args, fn) {\n      var path;\n\n      path = resolveFixturePath(fixturePath);\n      args = args || [];\n\n      invokeMocha(args.concat(['--reporter', 'json', path]), function (err, res) {\n        if (err) return fn(err);\n\n        try {\n          var result = JSON.parse(res.output);\n          result.code = res.code;\n        } catch (err) {\n          return fn(err);\n        }\n\n        fn(null, result);\n      });\n    }\n\n    return runMochaJSON;\n  }(),\n\n  /**\n   * Returns an array of diffs corresponding to exceptions thrown from specs,\n   * given the plaintext output (-C) of a mocha run.\n   *\n   * @param  {string}   output\n   * returns {string[]}\n   */\n  getDiffs: function () {\n    function getDiffs(output) {\n      var diffs, i, inDiff, inStackTrace;\n\n      diffs = [];\n      output.split('\\n').forEach(function (line) {\n        if (line.match(/^  \\d+\\)/)) {\n          // New spec, e.g. \"1) spec title\"\n          diffs.push([]);\n          i = diffs.length - 1;\n          inStackTrace = false;\n          inDiff = false;\n        } else if (!diffs.length || inStackTrace) {\n          // Haven't encountered a spec yet\n          // or we're in the middle of a stack trace\n          return;\n        } else if (line.indexOf('+ expected - actual') !== -1) {\n          inDiff = true;\n        } else if (line.match(/at Context/)) {\n          // At the start of a stack trace\n          inStackTrace = true;\n          inDiff = false;\n        } else if (inDiff) {\n          diffs[i].push(line);\n        }\n      });\n\n      // Ignore empty lines before/after diff\n      return diffs.map(function (diff) {\n        return diff.slice(1, -3).join('\\n');\n      });\n    }\n\n    return getDiffs;\n  }()\n};\n\nfunction invokeMocha(args, fn) {\n  var output, mocha, listener;\n\n  output = '';\n  mocha = spawn('./bin/mocha', args);\n\n  listener = function listener(data) {\n    output += data;\n  };\n\n  mocha.stdout.on('data', listener);\n  mocha.stderr.on('data', listener);\n  mocha.on('error', fn);\n\n  mocha.on('close', function (code) {\n    fn(null, {\n      output: output.split('\\n').join('\\n'),\n      code: code\n    });\n  });\n}\n\nfunction resolveFixturePath(fixture) {\n  return path.join('./test/integration/fixtures', fixture);\n}\n\nfunction getSummary(res) {\n  return ['passing', 'pending', 'failing'].reduce(function (summary, type) {\n    var pattern, match;\n\n    pattern = new RegExp('  (\\\\d+) ' + type + '\\\\s');\n    match = pattern.exec(res.output);\n    summary[type] = match ? parseInt(match, 10) : 0;\n\n    return summary;\n  }, res);\n}","ast":null,"map":{"version":3,"sources":["/packages/practicalmeteor:mocha/test/integration/helpers.js"],"names":[],"mappings":"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","file":"/packages/practicalmeteor:mocha/test/integration/helpers.js.map","sourcesContent":["var spawn = require('child_process').spawn;\nvar path  = require('path');\nvar fs = require('fs');\n\nmodule.exports = {\n  /**\n   * Invokes the mocha binary for the given fixture with color output disabled.\n   * Accepts an array of additional command line args to pass. The callback is\n   * invoked with a summary of the run, in addition to its output. The summary\n   * includes the number of passing, pending, and failing tests, as well as the\n   * exit code. Useful for testing different reporters.\n   *\n   * Example response:\n   * {\n   *   pending: 0,\n   *   passing: 0,\n   *   failing: 1,\n   *   code:    1,\n   *   output:  '...'\n   * }\n   *\n   * @param {string}   fixturePath\n   * @param {array}    args\n   * @param {function} fn\n   */\n  runMocha: function(fixturePath, args, fn) {\n    var path;\n\n    path = resolveFixturePath(fixturePath);\n    args = args || [];\n\n    invokeMocha(args.concat(['-C', path]), function(err, res) {\n      if (err) return fn(err);\n\n      fn(null, getSummary(res));\n    });\n  },\n\n  /**\n   * Invokes the mocha binary on the code of the body of the function.\n   * Accepts an array of additional command line args to pass. The callback is\n   * invoked with a summary of the run, in addition to its output. The summary\n   * includes the number of passing, pending, and failing tests, as well as the\n   * exit code. Useful for testing different reporters.\n   *\n   * Example response:\n   * {\n   *   pending: 0,\n   *   passing: 0,\n   *   failing: 1,\n   *   code:    1,\n   *   output:  '...'\n   * }\n   *\n   * @param {function} fixture\n   * @param {array}    args\n   * @param {function} fn\n   */\n  runMochaFunction: function(fixture, args, fn) {\n    var path = resolveFixturePath(fixture.name + '.js' || 'tempfile.js');\n    args = args || [];\n\n    var fixtureContent = 'var fn = ' + fixture.toString() + '; fn()';\n    fs.writeFileSync(path, fixtureContent, 'utf8');\n\n    function cleanup() {\n      fs.unlink(path);\n      fn.apply(this, arguments);\n    }\n\n    invokeMocha(args.concat(['-C', path]), function(err, res) {\n      if (err) {\n        return cleanup(err);\n      }\n\n      cleanup(null, getSummary(res));\n    });\n  },\n\n  /**\n   * Invokes the mocha binary for the given fixture using the JSON reporter,\n   * returning the parsed output, as well as exit code.\n   *\n   * @param {string}   fixturePath\n   * @param {array}    args\n   * @param {function} fn\n   */\n  runMochaJSON: function(fixturePath, args, fn) {\n    var path;\n\n    path = resolveFixturePath(fixturePath);\n    args = args || [];\n\n    invokeMocha(args.concat(['--reporter', 'json', path]), function(err, res) {\n      if (err) return fn(err);\n\n      try {\n        var result = JSON.parse(res.output);\n        result.code = res.code;\n      } catch (err) {\n        return fn(err);\n      }\n\n      fn(null, result);\n    });\n  },\n\n  /**\n   * Returns an array of diffs corresponding to exceptions thrown from specs,\n   * given the plaintext output (-C) of a mocha run.\n   *\n   * @param  {string}   output\n   * returns {string[]}\n   */\n  getDiffs: function(output) {\n    var diffs, i, inDiff, inStackTrace;\n\n    diffs = [];\n    output.split('\\n').forEach(function(line) {\n      if (line.match(/^  \\d+\\)/)) {\n        // New spec, e.g. \"1) spec title\"\n        diffs.push([]);\n        i = diffs.length - 1;\n        inStackTrace = false;\n        inDiff = false;\n      } else if (!diffs.length || inStackTrace) {\n        // Haven't encountered a spec yet\n        // or we're in the middle of a stack trace\n        return;\n      } else if (line.indexOf('+ expected - actual') !== -1) {\n        inDiff = true;\n      } else if (line.match(/at Context/)) {\n        // At the start of a stack trace\n        inStackTrace = true;\n        inDiff = false;\n      } else if (inDiff) {\n        diffs[i].push(line);\n      }\n    });\n\n    // Ignore empty lines before/after diff\n    return diffs.map(function(diff) {\n      return diff.slice(1, -3).join('\\n');\n    });\n  }\n};\n\nfunction invokeMocha(args, fn) {\n  var output, mocha, listener;\n\n  output = '';\n  mocha = spawn('./bin/mocha', args);\n\n  listener = function(data) {\n    output += data;\n  };\n\n  mocha.stdout.on('data', listener);\n  mocha.stderr.on('data', listener);\n  mocha.on('error', fn);\n\n  mocha.on('close', function(code) {\n    fn(null, {\n      output: output.split('\\n').join('\\n'),\n      code: code\n    });\n  });\n}\n\nfunction resolveFixturePath(fixture) {\n  return path.join('./test/integration/fixtures', fixture);\n}\n\nfunction getSummary(res) {\n  return ['passing', 'pending', 'failing'].reduce(function(summary, type) {\n    var pattern, match;\n\n    pattern = new RegExp('  (\\\\d+) ' + type + '\\\\s');\n    match = pattern.exec(res.output);\n    summary[type] = (match) ? parseInt(match, 10) : 0;\n\n    return summary;\n  }, res);\n}\n"]},"hash":"fe81a912ef852cef7092e5cd8ef4c4273ccb6b9a"}
