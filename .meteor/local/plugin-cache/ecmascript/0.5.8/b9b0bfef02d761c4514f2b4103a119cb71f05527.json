{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js","filenameRelative":"/packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js.map","sourceFileName":"/packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"issue-1991"},"ignored":false,"code":"function MemoryLeak() {\n  this.myArr = [];\n  for (var i = 0; i < 1000000; i++) {\n    this.myArr.push(i);\n  }\n}\n\nvar numOfTests = 300;\nfor (var i = 0; i < numOfTests; i += 1) {\n  /*\n   * This Test suite will crash V8 due to:\n   * 'FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory'\n   * if all the deferred functions references have not been cleared\n   */\n  describe('Memory Leak Suite #' + i, function () {\n\n    // The <closureVar> variable will be accessed by the test below.\n    // As long as those test's functions are\n    // referenced in memory, the closure variable may not be garbage collected\n    // as it is still referenced.\n    // * In a chrome heap snapshot it will appear under \"system / Context\" (a scope)\n    var closureVar;\n\n    before(function () {\n      var x = closureVar ? 1 : 2;\n    });\n\n    after(function () {\n      var x = closureVar[0];\n    });\n\n    beforeEach(function () {\n      var x = closureVar ? 1 : 2;\n    });\n\n    afterEach(function () {\n      var x = closureVar[0];\n    });\n\n    it('access a variable via a closure', function () {\n      // slow performance on older node.js versions\n      this.timeout(1000);\n      closureVar = new MemoryLeak();\n    });\n  });\n}","ast":null,"map":{"version":3,"sources":["/packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js"],"names":[],"mappings":"AAAA,SAAS,UAAT,GAAsB;AACpB,OAAK,KAAL,GAAa,EAAb;AACA,OAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAApB,EAA6B,GAA7B,EAAkC;AAChC,SAAK,KAAL,CAAW,IAAX,CAAgB,CAAhB;AACD;AACF;;AAED,IAAI,aAAa,GAAjB;AACA,KAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,UAApB,EAAgC,KAAK,CAArC,EAAwC;;;;;;AAMtC,WAAS,wBAAwB,CAAjC,EAAoC,YAAY;;;;;;;AAO9C,QAAI,UAAJ;;AAEA,WAAO,YAAY;AACjB,UAAI,IAAI,aAAa,CAAb,GAAiB,CAAzB;AACD,KAFD;;AAIA,UAAM,YAAY;AAChB,UAAI,IAAI,WAAW,CAAX,CAAR;AACD,KAFD;;AAIA,eAAW,YAAY;AACrB,UAAI,IAAI,aAAa,CAAb,GAAiB,CAAzB;AACD,KAFD;;AAIA,cAAU,YAAY;AACpB,UAAI,IAAI,WAAW,CAAX,CAAR;AACD,KAFD;;AAIA,OAAG,iCAAH,EAAsC,YAAY;;AAEhD,WAAK,OAAL,CAAa,IAAb;AACA,mBAAa,IAAI,UAAJ,EAAb;AACD,KAJD;AAMD,GA/BD;AAgCD","file":"/packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js.map","sourcesContent":["function MemoryLeak() {\n  this.myArr = [];\n  for (var i = 0; i < 1000000; i++) {\n    this.myArr.push(i)\n  }\n}\n\nvar numOfTests = 300;\nfor (var i = 0; i < numOfTests; i += 1) {\n  /*\n   * This Test suite will crash V8 due to:\n   * 'FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory'\n   * if all the deferred functions references have not been cleared\n   */\n  describe('Memory Leak Suite #' + i, function () {\n\n    // The <closureVar> variable will be accessed by the test below.\n    // As long as those test's functions are\n    // referenced in memory, the closure variable may not be garbage collected\n    // as it is still referenced.\n    // * In a chrome heap snapshot it will appear under \"system / Context\" (a scope)\n    var closureVar;\n\n    before(function () {\n      var x = closureVar ? 1 : 2\n    });\n\n    after(function () {\n      var x = closureVar[0]\n    });\n\n    beforeEach(function () {\n      var x = closureVar ? 1 : 2\n    });\n\n    afterEach(function () {\n      var x = closureVar[0]\n    });\n\n    it('access a variable via a closure', function () {\n      // slow performance on older node.js versions\n      this.timeout(1000);\n      closureVar = new MemoryLeak();\n    });\n\n  });\n}\n"]},"hash":"b9b0bfef02d761c4514f2b4103a119cb71f05527"}
